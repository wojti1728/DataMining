QuakeResiduals<-Quake.mod$residuals
QuakeFittedValues<-Quake.mod$fitted.values
# zad 7:
hist(QuakeFittedValues, QuakeResiduals)
# zad 7:
hist(QuakeResiduals)
hist(QuakeFittedValues)
# zad 8:
color<-rgb(0.1, 0.2, 0.8)
plot(jitter(dane$mag, amount = 0.05), dane$stations,pch=20, col = alpha(color,0.3))
plot(QuakeFittedValues, QuakeResiduals, pch=20, col=rgb(0.1,0.2,0.8), abline(h=0,col='red'))
# zad 8:
color<-rgb(0.1, 0.2, 0.8)
plot(jitter(dane$mag, amount = 0.05), dane$stations,pch=20, col = alpha(color,0.3), abline(h=))
plot(jitter(dane$mag, amount = 0.05), dane$stations,pch=20, col = alpha(color,0.3), abline(h=confint(jitter(dane$mag, amount = 0.05)), col='green'))
plot(jitter(dane$mag, amount = 0.05), dane$stations,pch=20, col = alpha(color,0.3), abline(h=confint(jitter(dane$mag, amount = 0.05)), col='green'))
plot(jitter(dane$mag, amount = 0.05), dane$stations,pch=20, col = alpha(color,0.3), abline(h=confint(dane$mag), col='green'))
# zad 8:
color<-rgb(0.1, 0.2, 0.8)
plot(jitter(dane$mag, amount = 0.05), dane$stations,pch=20, col = alpha(color,0.3), abline(h=confint(dane$mag), col='green'))
plot(jitter(dane$mag, amount = 0.05), dane$stations,pch=20, col = alpha(color,0.3), abline(h=confint(mag), col='green'))
plot(jitter(dane$mag, amount = 0.05), dane$stations,pch=20, col = alpha(color,0.3), abline(h=confint(dane$mag), col='green'))
confint(dane$mag)
confint(mag, data(dane))
confint(mag, data=dane)
mg<-dane$mag
confint(mg)
confint(mg)
confint(Quake.mod$residuals)
confint(Quake.mod)
confint(Quake.mod, level = 0.95)
tmp1<-confint(Quake.mod, level = 0.95)
color<-rgb(0.1, 0.2, 0.8)
plot(jitter(dane$mag, amount = 0.05), dane$stations,pch=20, col = alpha(color,0.3), abline(h=tmp1, col='green'))
tmp1<-confint(Quake.mod, level = 0.95)
color<-rgb(0.1, 0.2, 0.8)
plot(jitter(dane$mag, amount = 0.05), dane$stations,pch=20,
col = alpha(color,0.3),
abline(conf[1,1], conf[2,1])
abline(conf[1,2], conf[2,2])
abline(Quake.mod))
tmp1<-confint(Quake.mod, level = 0.95)
color<-rgb(0.1, 0.2, 0.8)
plot(jitter(dane$mag, amount = 0.05), dane$stations,pch=20,
abline(conf[1,1], conf[2,1])
abline(Quake.mod)
# zad 8:
conf<-confint(Quake.mod,level=0.95)
plot(jitter(quakes$mag,amount=0.05),quakes$stations,col=alpha(col,0.3),pch=20)
abline(conf[1,1],conf[2,1])
abline(conf[1,2],conf[2,2])
abline(Quake.mod)
color<-rgb(0.1, 0.2, 0.8)
plot(jitter(dane$mag, amount = 0.05), dane$stations,pch=20,
abline(conf[1,1], conf[2,1])
abline(conf[1,2], conf[2,2])
abline(Quake.mod)
tmp1<-confint(Quake.mod, level = 0.95)
color<-rgb(0.1, 0.2, 0.8)
plot(jitter(dane$mag, amount = 0.05), dane$stations,pch=20,
abline(conf[1,1], conf[2,1])
abline(conf[1,2], conf[2,2])
abline(Quake.mod)
tmp1<-confint(Quake.mod, level = 0.95)
color<-rgb(0.1, 0.2, 0.8)
plot(jitter(dane$mag, amount = 0.05), dane$stations,pch=20,
abline(conf[1,1], conf[2,1])
abline(conf[1,2], conf[2,2])
plot(QuakeFittedValues, QuakeResiduals, pch=20, col=rgb(0.1,0.2,0.8))
abline(conf[1,1], conf[2,1])
abline(conf[1,2], conf[2,2])
abline(Quake.mod)
plot(jitter(dane$mag, amount = 0.05), dane$stations,pch=20,col = alpha(color,0.3))
abline(conf[1,1], conf[2,1])
abline(conf[1,2], conf[2,2])
abline(Quake.mod)
dnorm(0)
dnorm(0)
x=seq(-5,5,0.1)
x
f=dnorm(x)
f
plot(f)
plot(f,type="l")
plot(x,f,type="l")
pnorm(f)
pnorm(1)
x=rnorm(1000)
z
x
sum(x>-1 & x<1)
x=rnorm(1000)
x
sum(x>-1 & x<1)
sum(x>-3 & x<3)
sum(x<-3 | x>3)
sum(x<-3 || x>3)
sum(x<-3 | x>3)
sum(x<-3 | x>3)
x=rnorm(1000)
x
sum(x<-3 | x>3)
x=rnorm(1000)
x
sum(x<-3 || x>3)
sum(x<-3)
x
x=rnorm(1000)
x
sum(x<(-3) | x>3)
x
x=rnorm(1000)
sum(x<(-3) | x>3)
sum(x<(-3) | x>3)
for (i in seq(1,10,1))
https://aghedupl-my.sharepoint.com/:x:/g/personal/hertel_student_agh_edu_pl/EZywQ_tUTQFJsUvWpIGEln0B-I-12Uo4SPN8ZvnRlOMD7g?e=DnkW66
for (i in seq(1,10,1)){}
for (i in seq(1,10,1)){
x<-rnorm(1000)
print(sum(x<(-3) | x>3))}
for (i in seq(1,10,1)){
x<-rnorm(1000)
(sum(x<(-3) | x>3))}
for (i in seq(1,10,1)){
print(sum(x<(-3) | x>3))}
for (i in seq(1,10,1)){
x<-rnorm(1000)
print(sum(x<(-3) | x>3))}
bin(0,0.1,1000)
x<-seq(100,200,0.1)
x
f<-dnorm(x)
f
f<-dnorm((x-165)/10
plot(x,f)
f<-dnorm((x-165)/10)
plot(x,f)
x<-seq(100,250,0.1)
x
f<-dnorm((x-165)/10)
x<-seq(100,250,0.1)
x
f<-dnorm((x-165)/10)
plot(x,f)
sum(x*f)
sum(x*f)/10
f<-dnorm((x,165,10)
sum(x*f)/10
x
f<-dnorm(x,165,10)
plot(x,f)
sum(x*f)
f<-dnorm(x,165,10)
plot(x,f)
sum(x*f)
library('ggplot2')
dane = diamonds
dane
head(dane)
View(dane)
# ZAD 2
type(dane)
# ZAD 2
names(dane) # nazwy zmiennych
clas(dane) # typy zmiennych
class(dane) # typy zmiennych
# zad 3
hist(dane$price)
mean(dane$price)
mediana(dane$price)
median(dane$price)
mean(dane$price)
median(dane$price)
# zad 4
library(dplyr)
# zad 4
library('dplyr)
# zad 4
library('dplyr')
# zad 4
library('dplyr')
# zad 4
library('dplyr')
dane %>%
filter(price > 10000)
dane %>%
filter(price > 10000)%>%
summarise(count(price))
dane %>%
filter(price > 10000)%>%
summarise(count(price))
summarise(count=n()
# zad 4
library('dplyr')
dane %>%
summarise(count=n()
dane %>%
filter(price > 10000)%>%
summarise(count=n())
dane %>%
filter(price > 10000)%>%
summarise(count=n())
# zad 5
install.packages('mosaic')
library('mosaic')
mosaic::mean(price~clarify)
mosaic::mean(price~clarity)
mosaic::mean(price~clarity, dane)
mosaic::mean(price~clarity, data=dane)
mosaic::mean(price~clarity, data=dane)
# zad 6
boxplot(dane$price~dane$carat,dane$color)
ggplot(d,aes(x=color,y=price/carat,col=color))+
geom_boxplot()
ggplot(d,aes(x=color,y=price/carat,col=color))+
geom_boxplot()
ggplot(dane,aes(x=color,y=price/carat,col=color))+
geom_boxplot()
# zad 6
boxplot(dane$price~dane$carat,dane$color)
ggplot(dane,aes(x=color,y=price/carat,col=color))+
geom_boxplot()
# zad 6
boxplot(dane$price/dane$carat,dane$color)
ggplot(dane,aes(x=color,y=price/carat,col=color))+
geom_boxplot()
# zad 6
boxplot(dane$price/dane$carat~dane$color)
ggplot(dane,aes(x=color,y=price/carat,col=color))+
geom_boxplot()
# zad 6
boxplot(dane$price/dane$carat~dane$color)
ggplot(dane,aes(x=color,y=price/carat,col=color))+
geom_boxplot()
ggplot(dane, aes(x=color, y=price/carat, col=color))+
geom_boxplot()
ggplot(dane, aes(x=clarity, y=price))+
geom_boxplot()
ggplot(dane, aes(x=clarity, y=price, col=clarity))+
geom_boxplot()
# zad 8
plot(dane$carat, dane$price)
# zad 8
plot(dane$carat, dane$price)
gplot(dane, aes(carat, price))+geom_point()
ggplot(dane, aes(carat, price))+geom_point()
# zad 8
plot(dane$carat, dane$price)
ggplot(dane, aes(carat, price))+geom_point()
# zad 9
m<-mutate(dane, log_carat=log10(carat), log_price=log10(price))
m
ggplot(m, aes(log_carat, log_price))
ggplot(m, aes(log_carat, log_price))+geom_point()
ggplot(m, aes(x=log_carat, y=log_price))+geom_point()
dane %>%
filter(price > 10000)%>%
summarise(count=n())
# zad 10
# model liniowy (lm)
model1<-lm(log_price~log_carat, m)
model1
plot(log_price~log_carat, m)
plot(log_price~log_carat, data=m)
plot(log_price~log_carat, data=m, type='l')
# zad 11
model2<-lm(log_price~color+cut)
# zad 11
model2<-lm(log_price~color+cut, dane=m)
# zad 11
model2<-lm(log_price~color+cut, n)
# zad 11
model2<-lm(log_price~color+cut, data=m)
model2
mosaic::mean(price~clarity, data=dane)
rexp(10, 1)
sd(rpois(250, 250))
sd(rpois(250, 50))
sd(rpois(250, 50))^2
sd(rpois(250, 50))^2
sd(rpois(250, 50))^2
replicate(10, sd(rpois(250, 50))^2)
rchi(10, 5)
rchisq(10, 5)
replicte(10, sum())
replicte(10, sum(rnorm(5)^2))
replicte(10, sum(rnorm(5)^2))
replicate(10, sum(rnorm(5)^2))
mean(replicate(1000, sum(rnorm(5)^2)))
mean(replicate(1000, sum(rnorm(5)^2)))
mean(rchisq(1000, 5))
mean(replicate(1000, sum(rnorm(5)^2)))
sd(replicate(1000, sum(rnorm(5)^2)))
sd(rchisq(1000, 5))
x=seq(20)
x
x=seq(0,20)
x
y=x+rnorn(21)
y=x+rnorm(21)
y
plot(x,y)
a=sum(x*y)/sum(x*x)
a
a=sum(x*(x+rnorm(21)))/sum(x*x)
a
a=replicate(sum(x*(x+rnorm(21)))/sum(x*x))
a
a=replicate(10, sum(x*(x+rnorm(21)))/sum(x*x))
A
a
sd(replicate(10, sum(x*(x+rnorm(21)))/sum(x*x)))
install.packages("ncdf4")
install.packages("dplyr")
install.packages("sp")
install.packages("fields")
install.packages("raster")
install.packages("rgdal")
install.packages("terra")
install.packages("purrr")
install.packages("magrittr")
install.packages("tidyr")
update.packages(ask = FALSE)
packageVersion("tidyverse")
install.packages("tidyverse")
library(liver)
install.packages("liver")
library(liver)
data("cereal")
View(cereal)
View(cereal)
library(corrplot)
cor_matrixp<-round(cor(cereal[4:16]),2)
View(conf)
boxplot(cereal$rating)
boxplot(cereal$rating~cereal$type)
boxplot(cereal$rating)
library(liver)
data("cereal")
cereal->data("cereal")
cereal<-data("cereal")
train<-cereal[-c(5, 15, 25, 35, 55),]
test<-cereal[c(5, 15, 25, 35, 55),]
sets <- sample(1:nrow(cereals), 0.9 * nrow(cereals))
cereals<-data("cereal")
sets <- sample(1:nrow(cereals), 0.9 * nrow(cereals))
sets <- sample(1:nrow(cereals), 0.9 * nrow(cereals))
cereals<-data("cereal")
train2<- cereals [sets,]
test2<- cereals[-sets,]
sets <- sample(1:nrow(cereals), 0.9 * nrow(cereals))
cereals<-data("cereal")
library(liver)
cereals<-data("cereal")
data("cereal")
Wybór celowy
train<-cereal[-c(5, 15, 25, 35, 55),]
test<-cereal[c(5, 15, 25, 35, 55),]
sets <- sample(1:nrow(cereals), 0.9 * nrow(cereals))
sets <- sample(1:nrow(cereal), 0.9 * nrow(cereal))
train2<- cereals [sets,]
test2<- cereals[-sets,]
train2<- cereals [sets,]
test2<- cereals[-sets,]
train2<- cereals[sets,]
train2<- cereal[sets,]
test2<- cereal[-sets,]
#model 1: Regresja liniowa
m1<-lm(rating~sugars, train)
summary(m1)
# zwracamy uwage na poprawnosc modelu (czyli jest istotny statystyczny)
# Od coeffitians:
# nasz model jest istotny statystycznie to patrzmym na ilosc
# gwiazdek na koniec suggars (jesli jedna to juz git, im wiecej tym lepiej)
# jesli musimy usunac jakies zmienne, to wtedy usuwamy z modelu te z najwiekszym z p
# Rating = 59.34-2.07 * sugars (do przewidywania w przyszlosci)
# RSE (o ile średnio się mylimy)
# R-squared - wspołczynnik determinacji który tłumaczy nam jak dobry jest nasz model
#
plot(train$rating, type="l", col="red")
lines(m1$fitted.values, type="l", col="blue")
summary(m1)
#model 1: Regresja liniowa
m1<-lm(rating~sugars, train2)
summary(m1)
# zwracamy uwage na poprawnosc modelu (czyli jest istotny statystyczny)
# Od coeffitians:
# nasz model jest istotny statystycznie to patrzmym na ilosc
# gwiazdek na koniec suggars (jesli jedna to juz git, im wiecej tym lepiej)
# jesli musimy usunac jakies zmienne, to wtedy usuwamy z modelu te z najwiekszym z p
# Rating = 59.34-2.07 * sugars (do przewidywania w przyszlosci)
# RSE (o ile średnio się mylimy)
# R-squared - wspołczynnik determinacji który tłumaczy nam jak dobry jest nasz model
#
plot(train$rating, type="l", col="red")
lines(m1$fitted.values, type="l", col="blue")
#model 1: Regresja liniowa
m1<-lm(rating~sugars, train2)
summary(m1)
# zwracamy uwage na poprawnosc modelu (czyli jest istotny statystyczny)
# Od coeffitians:
# nasz model jest istotny statystycznie to patrzmym na ilosc
# gwiazdek na koniec suggars (jesli jedna to juz git, im wiecej tym lepiej)
# jesli musimy usunac jakies zmienne, to wtedy usuwamy z modelu te z najwiekszym z p
# Rating = 59.34-2.07 * sugars (do przewidywania w przyszlosci)
# RSE (o ile średnio się mylimy)
# R-squared - wspołczynnik determinacji który tłumaczy nam jak dobry jest nasz model
#
plot(train$rating, type="l", col="red")
lines(m1$fitted.values, type="l", col="blue")
# zwracamy uwage na poprawnosc modelu (czyli jest istotny statystyczny)
# Od coeffitians:
# nasz model jest istotny statystycznie to patrzmym na ilosc
# gwiazdek na koniec suggars (jesli jedna to juz git, im wiecej tym lepiej)
# jesli musimy usunac jakies zmienne, to wtedy usuwamy z modelu te z najwiekszym z p
# Rating = 59.34-2.07 * sugars (do przewidywania w przyszlosci)
# RSE (o ile średnio się mylimy)
# R-squared - wspołczynnik determinacji który tłumaczy nam jak dobry jest nasz model
#
plot(train2$rating, type="l", col="red")
lines(m1$fitted.values, type="l", col="blue")
#kryterium porównawcze z innymi modelami
aic_m1<-AIC(m1)
bic_m1<-BIC(m1)
#reszty
hist(m1$residuals)
pacf(m1$residuals)
acf(m1$residuals)
#prognozy
library(MLmetrics)
install.packages('MLmetrics')
#prognozy
library(MLmetrics)
##
## Dołączanie pakietu: 'MLmetrics'
## Następujący obiekt został zakryty z 'package:base':
##
## Recall
pred_m1<-predict(m1, newdata = test)
mape_m1<-MAPE(pred_m1, test$rating)
plot(m1$fitted.values,m1$residuals)
##
## Dołączanie pakietu: 'MLmetrics'
## Następujący obiekt został zakryty z 'package:base':
##
## Recall
pred_m1<-predict(m1, newdata = test2)
mape_m1<-MAPE(pred_m1, test$rating)
pred_m1
mape_m1<-MAPE(pred_m1, test$rating)
mape_m1
aic_m1<-AIC(m1)
aic_m1
mape_m1<-MAPE(pred_m1, test2$rating)
mape_m1
# zad 1
View(data)
# zad 1
View(cereal)
sets<-sample(1:nrow(cereal), n_test)
n_test<-5
sets<-sample(1:nrow(cereal), n_test)
test_data<-cereal[sets,]
train_data<-cereal[-sets,]
v<-cereal[,4:ncol(cereal)]
cor_matrix<-cor(v)
corrplot(cor_matrix)
# model
model<-lm(rating ~ sugars + fiber + fat + sodium, data = train_data)
# ocena jakosci modelu
summary(model)
# model
model<-lm(rating ~ sugars + fiber + fat + sodium, data = train_data)
# ocena jakosci modelu
summary(model)
par(nfrow = c(1,1))
plot(train_data$ratin, type='l', col='red')
lines(model$fitted.values, type='l', col='blue')
par(mfrow = c(1,1))
plot(train_data$ratin, type='l', col='red')
lines(model$fitted.values, type='l', col='blue')
par(mfrow=c(2,2))
hist(model$residuals)
acf(model$residuals)
pacf(model$residuals)
plot(model$residuals~model$fitted.values)
par(mfrow = c(1, 1))
aic_m1<-AIC(model)
aic_m1
pred_model<-predict(model, newdata = test_data)
pred_model
mape_model<-MAPE(pred_model, test_data$rating)
mape_model
par(mfrow = c(1,1))
par(mfrow = c(1,1))
plot(train_data$ratin, type='l', col='red')
lines(model$fitted.values, type='l', col='blue')
# zad 2
setwd("D:/AGH-studia/Semestr_7/Data_Mininig/cw3/DataMining")
# zad 2
setwd("D:/AGH-studia/Semestr_7/Data_Mininig/cw3/")
data <- read.csv('Series_G.csv'
data
data <- read.csv('Series_G.csv')
data
air_passangers<-read.table("Series_G.csv",header = TRUE, sep = "\t")
air_passangers
air_passangers<-read.table("Series_G.csv",header = FALSE, sep = "\t")
air_passangers
air_passangers$V1
szereg_czasowy<-ts(data = air_passangers$V1, frequency = 12, start=c(1949,1), end = c(1960,12))
szereg_czasowy
